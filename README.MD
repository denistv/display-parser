# Предыстория
Это реализация простого парсера сайта с моделями мониторов **displayspecifications.com**.

Когда-то у меня возникла проблема выбора нового монитора, но большинство маркетплейсов по какой-то причине не имели у себя фильтра по параметру PPI (число точек на дюйм), который был для меня определяющим фактором при выборе.

По этой причине ради спортивного интереса, решил спарсить все существующие мониторы с сайта.
Затем загрузить данные в базу и простым запросом вытянуть модели, которые удовлетворяют моим критериям.

В дальнейшем превратилось в пример для демонстрации своего кода.

# Описание реализации
### Принцип работы
В начале приложение собирает список существующих на сайте брендов мониторов.
Каждая страница с брендом содержит полный список мониторов, произведенных им.
Затем URL страницы с брендом передается в коллектор моделей мониторов.
Он в свою очередь собирает URL на конкретные модели мониторов и передает их непосредственно парсеру страниц монитора.
Парсер страниц разбирает их, извлекая требуемые параметры, наполняя внутреннюю сущность (internal/domain/model.go) данными.
Затем сущность сохраняется в БД.

После того, как парсер отработал - можно ручками идти в БД и составлять произвольные запросы для поиска нужного монитора по требуемым критериям.

### Описание шагов пайплайна
Приложение представляет из себя пайплайн, состоящий из нескольких этапов:
1. Сборщик URL брендов мониторов (**internal/services/pipeline/brands_collector.go**)
2. Сборщик URL страниц, на которых содержатся ссылки на модели мониторов (**internal/services/pipeline/pages_collector.go**)
3. Сборщик URL на модели мониторов бренда (**internal/services/pipeline/models_url_collector.go**)
4. Парсер страницы с описанием монитора (**internal/services/pipeline/model_parser.go**)



# Описание команд
Прогон линтеров:
> $ make lint

Прогон тестов:
> $ make test

Сборка docker-образа:
> $ make image

# TODO
#### High:
1. сделать враппер для http клиента с моком
2. сделать gracefull shutdown, прокинуть контекст в коллекторы
3. cmd's

#### Average
1. реализовать враппер для логгера
2. сделать хранение параметров логгера в гошном контексте
3. config (env, command line params)
4. sql-migrator
5. конфиг для линтера

#### Low:
3. описание проекта

# Q&A по реализации:

**Q:** Почему задействован пайплайн, когда можно было бы написать последовательный код, это же просто парсер?

**A:** Да, можно просто написать последовательный код (вместо разделения на этапы и связывания их через каналы) и в нужный момент запускать горутины для распараллеливания каких-то операций.
В данном случае цель заключается в демонстрации применения подхода с пайплайнами на простом примере с парсингом сайта, где процесс состоит из множества частей.
Он хорош тем, что мы явно разбиваем какую-то задачу на этапы и можем произвольно масштабировать каждый из них (запускать больше/меньше горутин в рамках этапа пайплайна, по потребности).
Сами этапы связываются посредством каналов. При этом, реализация каждого этапа **явно** отделена от другой, что делает код более поддерживаемым и масштабируемым за счет того, чот логика обработки не размазывается/не смешивается с другими частями приложения.
Применение пайплайнов оправдано не во всех задачах, поэтому данный код нужно воспринимать лишь как демонстрацию подхода.
**TODO** подумать над формулировкой  первого предложения
